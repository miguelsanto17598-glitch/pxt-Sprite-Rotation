{"entries":[{"timestamp":1758470622827,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":200,"length1":35,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1758470675252,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block></xml>"]]}]}]},{"timestamp":1758478915453,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":200,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]}]},{"timestamp":1758478920590,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":64,"length1":53,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":200,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]}]},{"timestamp":1758479226277,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":87,"length1":93,"diffs":[[1,"        \"sprite-scaling\": \"*\"\n"]]}]}]},{"timestamp":1758479800234,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":294,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]}]},{"timestamp":1758480913865,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":158,"diffs":[[1,""]]},{"start1":1,"length1":794,"diffs":[[1,""]]}]}]},{"timestamp":1758481016810,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1028,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":43,"diffs":[[1,""]]},{"start1":226,"length1":255,"diffs":[[1,"    export function init(sprite: Sprite) {\n        spriteData[sprite.id] = {\n            originalImage: sprite.image.clone(),\n            currentRotation: 0,\n            isFlippedY: false\n"]]},{"start1":424,"length1":38,"diffs":[[1,""]]},{"start1":431,"length1":256,"diffs":[[1,""]]},{"start1":630,"length1":0,"diffs":[[1,"\n"]]},{"start1":675,"length1":116,"diffs":[[1,""]]},{"start1":741,"length1":39,"diffs":[[1,"        let data = spriteData[sprite.id];\n        if (!data) init(sprite);\n"]]},{"start1":908,"length1":37,"diffs":[[1,"        sprite.image.rotate(angle);\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":294,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1758470622826,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"n\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1758478915453,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block></xml>","main.ts":"","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"n\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1758480913865,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"","README.md":" //% weight=100 color=#ff6600 icon=\"\\uf021\"\r\nnamespace spriteRotate {\r\n    interface SpriteRotationData {\r\n        originalImage: Image;\r\n        currentRotation: number;\r\n        isFlippedY: boolean;\r\n    }\r\n\r\n    const spriteData: { [key: number]: SpriteRotationData } = {};\r\n\r\n    // Track the last single input state to prevent flip-flopping\r\n    let lastValidLeftState = false;\r\n    let lastValidRightState = false;\r\n    let inputProtectionEnabled = false;\r\n\r\n    /**\r\n     * Enable automatic input conflict detection for sprite transformations\r\n     */\r\n    //% block=\"enable sprite rotation input protection\"\r\n    //% weight=75\r\n    export function enableInputProtection(): void {\r\n        inputProtectionEnabled = true;\r\n    }\r\n\r\n    /**\r\n     * Check if we should process the transformation based on input states\r\n     */\r\n    function shouldProcessTransformation(): boolean {\r\n        if (!inputProtectionEnabled) return true;\r\n\r\n        let leftPressed = controller.left.isPressed();\r\n        let rightPressed = controller.right.isPressed();\r\n\r\n        // If both are pressed, maintain the last valid state\r\n        if (leftPressed && rightPressed) {\r\n            return false; // Don't process any changes\r\n        }\r\n\r\n        // Update last valid states when only one or neither is pressed\r\n        if (leftPressed && !rightPressed) {\r\n            lastValidLeftState = true;\r\n            lastValidRightState = false;\r\n        } else if (rightPressed && !leftPressed) {\r\n            lastValidLeftState = false;\r\n            lastValidRightState = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the absolute rotation of a sprite\r\n     * @param sprite the sprite to rotate\r\n     * @param angle the angle in degrees\r\n     */\r\n    //% block=\"set %sprite=variables_get(mySprite) rotation to %angle degrees\"\r\n    //% weight=100\r\n    export function setRotation(sprite: Sprite, angle: number): void {\r\n        if (!sprite) return;\r\n        const spriteId = sprite.id;\r\n\r\n        // Initialize sprite data if it doesn't exist\r\n        if (!spriteData[spriteId]) {\r\n            spriteData[spriteId] = {\r\n                originalImage: sprite.image.clone(),\r\n                currentRotation: 0,\r\n                isFlippedY: false\r\n            };\r\n        }\r\n\r\n        const data = spriteData[spriteId];\r\n        const normalizedAngle = ((angle % 360) + 360) % 360;\r\n\r\n        // Only update if angle actually changed - THIS IS KEY FOR SMOOTHNESS\r\n        if (data.currentRotation !== normalizedAngle) {\r\n            data.currentRotation = normalizedAngle;\r\n            applyTransformation(sprite, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set vertical flip state of a sprite\r\n     * @param sprite the sprite to flip\r\n     * @param flipped whether the sprite should be flipped vertically\r\n     */\r\n    //% block=\"set %sprite=variables_get(mySprite) vertical flip %flipped\"\r\n    //% weight=95\r\n    export function setVerticalFlip(sprite: Sprite, flipped: boolean): void {\r\n        if (!sprite) return;\r\n\r\n        // Check if we should ignore this transformation due to input conflicts\r\n        if (!shouldProcessTransformation()) {\r\n            return;\r\n        }\r\n\r\n        const spriteId = sprite.id;\r\n\r\n        // Initialize sprite data if it doesn't exist\r\n        if (!spriteData[spriteId]) {\r\n            spriteData[spriteId] = {\r\n                originalImage: sprite.image.clone(),\r\n                currentRotation: 0,\r\n                isFlippedY: false\r\n            };\r\n        }\r\n\r\n        const data = spriteData[spriteId];\r\n\r\n        // Only update if the flip state actually changed - THIS IS KEY FOR SMOOTHNESS\r\n        if (data.isFlippedY !== flipped) {\r\n            data.isFlippedY = flipped;\r\n            applyTransformation(sprite, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make sprite1 rotate to face sprite2\r\n     * @param sprite1 the sprite that will rotate\r\n     * @param sprite2 the sprite to face towards\r\n     */\r\n    //% block=\"make %sprite1=variables_get(mySprite) rotate towards %sprite2=variables_get(mySprite2)\"\r\n    //% weight=90\r\n    export function rotateTowards(sprite1: Sprite, sprite2: Sprite): void {\r\n        if (!sprite1 || !sprite2) return;\r\n        const deltaX = sprite2.x - sprite1.x;\r\n        const deltaY = sprite2.y - sprite1.y;\r\n        const angleRadians = Math.atan2(deltaY, deltaX);\r\n        const angleDegrees = angleRadians * (180 / Math.PI);\r\n        setRotation(sprite1, angleDegrees);\r\n    }\r\n\r\n    /**\r\n     * Continuously make sprite1 rotate to face sprite2\r\n     * @param sprite1 the sprite that will rotate\r\n     * @param sprite2 the sprite to face towards\r\n     */\r\n    //% block=\"continuously make %sprite1=variables_get(mySprite) rotate towards %sprite2=variables_get(mySprite2)\"\r\n    //% weight=80\r\n    export function continuouslyRotateTowards(sprite1: Sprite, sprite2: Sprite): void {\r\n        game.onUpdate(function () {\r\n            rotateTowards(sprite1, sprite2);\r\n        });\r\n    }\r\n\r\n    function applyTransformation(sprite: Sprite, data: SpriteRotationData): void {\r\n        const currentX = sprite.x;\r\n        const currentY = sprite.y;\r\n        let transformedImage = data.originalImage.clone();\r\n\r\n        // Apply vertical flip first if needed\r\n        if (data.isFlippedY) {\r\n            transformedImage = flipImageVertically(transformedImage);\r\n        }\r\n\r\n        // Then apply rotation\r\n        if (data.currentRotation !== 0) {\r\n            transformedImage = rotateImage(transformedImage, data.currentRotation);\r\n        }\r\n\r\n        sprite.setImage(transformedImage);\r\n        sprite.setPosition(currentX, currentY);\r\n    }\r\n\r\n    function flipImageVertically(img: Image): Image {\r\n        const width = img.width;\r\n        const height = img.height;\r\n        const flippedImg = image.create(width, height);\r\n        for (let x = 0; x < width; x++) {\r\n            for (let y = 0; y < height; y++) {\r\n                const color = img.getPixel(x, y);\r\n                flippedImg.setPixel(x, height - 1 - y, color);\r\n            }\r\n        }\r\n        return flippedImg;\r\n    }\r\n\r\n    function rotateImage(img: Image, angleDegrees: number): Image {\r\n        const angleRadians = angleDegrees * Math.PI / 180;\r\n        const cos = Math.cos(angleRadians);\r\n        const sin = Math.sin(angleRadians);\r\n        const width = img.width;\r\n        const height = img.height;\r\n        const newWidth = Math.ceil(Math.abs(width * cos) + Math.abs(height * sin));\r\n        const newHeight = Math.ceil(Math.abs(width * sin) + Math.abs(height * cos));\r\n        const rotatedImg = image.create(newWidth, newHeight);\r\n        const centerX = width / 2;\r\n        const centerY = height / 2;\r\n        const newCenterX = newWidth / 2;\r\n        const newCenterY = newHeight / 2;\r\n\r\n        for (let x = 0; x < newWidth; x++) {\r\n            for (let y = 0; y < newHeight; y++) {\r\n                const translatedX = x - newCenterX;\r\n                const translatedY = y - newCenterY;\r\n                const sourceX = Math.round(translatedX * cos + translatedY * sin + centerX);\r\n                const sourceY = Math.round(-translatedX * sin + translatedY * cos + centerY);\r\n\r\n                if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {\r\n                    const color = img.getPixel(sourceX, sourceY);\r\n                    if (color !== 0) {\r\n                        rotatedImg.setPixel(x, y, color);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return rotatedImg;\r\n    }\r\n}\r\n","assets.json":"","pxt.json":"{\n    \"name\": \"n\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"sprite-scaling\": \"*\",\n        \"carnival\": \"github:microsoft/arcade-carnival#v0.0.7\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}}],"shares":[],"lastSaveTime":1758481586577}